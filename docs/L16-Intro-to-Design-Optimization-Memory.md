## 今日计划

- 物理设计优化简介
- 存储器的限制
- 架构层面的优化干预：分Bank、流水线等

## 为什么要优化物理设计？

### 提高**效率**

真正的问题是：**何时值得付出优化努力？**

- 大多数情况下优化是出于

  性能

  或

  成本

  的驱动。

  - 否则，编写运行在处理器上的软件通常会更简单。

- 物理设计优化会在设计的不同阶段以不同方式进行：

  - 需要关注优化努力的**成本/收益比**。

## 优化的指标是什么？（PPA）

PPA（功耗、性能、面积）是硬件优化的核心目标：

1. **功耗（Power）**
   - 影响电池寿命、热量（散热需求）和成本（电费、供电系统）。
2. **性能（Performance）**
   - 运行任务的速度，即完成应用目标的时间。
3. **面积（Area）**
   - 芯片或FPGA的资源需求，与制造成本直接相关。

## 优化需要目标（Target/Goal）

在优化开始前，必须**设定目标**，包括技术实现和硬件约束：

1. **选择实现技术**

   - 确定具体实现方式（如特定的ASIC工艺或FPGA）。
   - 与软件优化不同，硬件优化很多情况下**无法移植**到其他技术上。
   - 工具通常需要某些**约束**作为输入，例如目标时钟频率或芯片面积等。

2. **先测量，再优化**

   - 确保优化目标是**实际问题**（例如，是否真的存在功耗过高、性能不足等瓶颈）。
   - 同时评估优化所需的投入和可能的收益：
     - 小收益的优化可能得不偿失。

3. **硬件生成器简化了优化过程**

   - 硬件生成器能快速生成多种设计配置，从而评估不同的设计备选：
     - 确定哪个设计最优在一开始可能很难。
     - 使用生成器更容易探索不同设计并找到更可移植的解决方案。

4. **在PPA指标之间进行权衡（Tradeoffs）**

   - 很多优化会影响多个指标，因此需要在功耗、性能和面积之间找到

     平衡点：

     - 后续会进一步讨论如何进行指标间的权衡。

## 软件开发与芯片设计的差异

### **“简单”的软件开发世界**

- 主要精力集中在**实现**（implementation）和**验证**（verification）上。

- 通常只需优化一个指标：

  性能（performance）

  - 大多数性能优化具有很高的可移植性（例如，大多数CPU的优化方式相似）。

- 工具（如编译器）高度自动化，几乎不会产生错误的结果。

### **“复杂”的芯片设计世界**

- 在完成实现后，**物理设计优化**与**验证**是更大的挑战。

- 需要优化多个指标：

  功耗（power）

  、

  性能（performance）

  、

  面积（area，PPA）

  - 这些优化可能高度依赖具体的技术实现。

- 工具（例如EDA工具流）需要**大量人工干预**和监督。

## 硬件设计的对比哲学

实际的设计流程可能会融合不同的方法，这里对两种极端情况进行对比：

### **瀑布模型（Waterfall）**

- 按阶段完成设计，每个阶段完全完成后才能继续下一个阶段：

  1. **设计（Design）**
  2. **规范（Specification）**
  3. **实现（Implementation）**
  4. **集成（Integration）**
  5. **优化（Optimization）**
  6. **验证（Verification）**

- 劣势：

  - 在后期集成时，若发现问题，则需要重新优化和验证。

### **敏捷开发（Agile）**

- 设计流程是

  迭代的

  ，每轮循环包括以下步骤：

  - **设计 → 实现 → 验证 → 优化**
  - 可以随时根据需求调整设计并不断优化。

- 特点：

  - 在早期就开始集成和验证设计，降低后期风险。
  - 逐步增加功能并持续优化。
  - 可根据需要重复多次循环，直到最终产品达到目标。

## 芯片设计工具流程的主要阶段

### **主要流程概述**

1. **RTL**
   - 硬件设计的起点，描述系统的行为和结构。
2. **综合（Synthesis）**
   - 将逻辑设计映射到目标技术上（例如，FPGA或ASIC）。
   - 处理设计逻辑，并生成用于物理实现的门级网表。
3. **布局（Placement）**
   - 布局芯片的组件。
   - 确保逻辑元件和存储器等模块在芯片上有合适的位置。
4. **布线（Routing）**
   - 连接布局中的组件，使用信号线完成物理连接。
5. **芯片设计完成（Chip Design）**
   - 最终生成可用于制造的设计。

### **工具流程的复杂性**

- 实际工具流程**远比上述流程复杂**。

- 不同阶段的工具会

  频繁交互

  并可能需要多次运行：

  - 例如：重新综合、重新布局、重新布线以优化关键路径。

- 设计的后期需要更多步骤以处理物理细节并支持制造过程。

- 在每个步骤中，都需要进行**设计验证**，以确保流程正确。

## 为什么要关注存储器？

存储器在芯片设计中是**一个关键组件**，可能显著影响**成本**和**性能**。

### **存储器如何影响成本？**

- 片外存储器：

  - 存储器组件的价格（如DRAM或SRAM）。
  - 以及接口引脚（pin）的数量需求。

- 片上存储器：

  - 存储器可能占用大量的芯片面积，影响最终成本。

### **存储器如何限制性能？**

- **存储器延迟**是计算机架构的主要瓶颈之一。
- **存储器带宽限制**可能对整体吞吐量产生上限。

### **存储器的用途**

- 存储应用程序数据和中间状态。
- 将存储器视为一个通用的“连接器（connector）”：
  - 在时间上传递数据。
  - 在设计阶段，生产者和消费者的关系可能尚未明确。

## 存储器术语

1. **容量（Capacity）**
   - 存储大小，例如比特、字节或字的数量。
2. **延迟（Latency）**
   - 读取数据或完成写操作所需的时间。
3. **带宽（Bandwidth）**
   - 总体吞吐量，例如每秒传输的字节数（数据量/时间）。
4. **请求（Request）**
   - 对存储器发出的命令，例如读取或写入操作。
5. **访问宽度（Access Width）**
   - 每次请求传输的数据量。
6. **端口（Port）**
   - 访问存储器的方式：
     - 常见类型包括只读、只写、读写。
7. **请求飞行中（Requests in Flight）**
   - 已经发送到存储器但尚未完成的请求。

### **存储器接口示例**

- **写端口（write port）**：
  - 包括使能信号（enable）、地址（address）和数据（data）。
  - 例如：容量由存储字数 * 每字比特数决定。
- **读端口（read port）**：
  - 包括使能信号（enable）、地址（address）和数据输出（data）。
  - 访问宽度（Access Width）决定单次请求的数据量。

## Little's Law 和存储器设计的考量

### **Little's Law**

**公式**: 并行性（Parallelism）= 吞吐量（Throughput）× 延迟（Latency）

#### **意义**

- 是架构师用于分析权衡的有用工具。
- 公式中的变量代表**平均值**，例如平均延迟、平均吞吐量。
- 通常一个指标是固定的，通过改进另一个指标来优化系统性能。
  - **示例**：如果延迟是固定的，为了提升吞吐量，需要增加并行性。

#### **优化实例**

- 如果存储器的访问延迟已经很低，而性能依然受限，可以通过增加并行的请求（并行性）来提升总吞吐量。

## 存储器的实际考量与限制

**目标**: 降低存储器访问对**成本**和**性能**的影响。

### **常见问题**

1. 存储器延迟太高
   - 导致性能瓶颈。
2. 端口数量不足
   - 很难为存储器增加足够的端口支持多请求访问。
3. 带宽不足
   - 限制系统的吞吐量。

### **典型解决方法**

1. 减少存储容量需求
   - 选择更高密度（更便宜）的存储技术。
2. 提高设计对延迟的容忍度
   - 在架构设计中容忍更大的延迟（例如通过预取）。
3. 减少带宽需求
   - 通过压缩数据或优化请求模式降低带宽占用。

### **存储器技术权衡**

不同存储技术在**成本/密度**与**性能/能效**之间存在权衡：

- 从最昂贵/最快到最便宜/最慢的技术：
  - **寄存器（Register）**
  - **SRAM（静态随机存储器）**
  - **DRAM（动态随机存储器）**
  - **PCM（相变存储器）**
  - **闪存（Flash Memory）**

## 架构干预：存储器分Bank技术（Banking）

### **引入Bank化（Banking）**

**问题**:
 应用程序需要的请求带宽超过了单一存储器能够实现的限度。

- 存储器技术通常只能提供有限的端口支持。
- 延迟已经被优化到当前技术所能支持的极限。

**解决方案**:
 **Bank化（Banking）**

- 将存储器分成多个**Bank**，每个Bank可以独立处理请求。
- 增加请求并行性，提高总带宽。
- 实现时，Bank化可以**参数化设计**以适应不同需求。

### **Bank 化的架构**

1. **单一存储器**
   - 所有请求通过一个集中存储器处理，可能形成瓶颈。
2. **银行化存储器（Banked Memory）**
   - 将存储器划分为多个银行（如 Bank 1、Bank 2）。
   - 每个银行处理特定部分的数据，提高并行性和吞吐量。

## 架构干预：银行化的设计考量

### **如何将请求分配到不同的Bank？**

1. **分区（Partition）**
   - 根据地址对存储器空间进行分区（例如 N 个Bank，每个存储器分 1/N 的数据）。
   - 请求通过哈希地址分配到正确的Bank。
2. **数据复制（Replication）**
   - 数据在多个Bank中复制（所有Bank存储相同的数据）。
   - 这种方法最适合**增加读取端口的数量**。

### **Bank端口的设计**

1. **独立端口（Independent Ports）**
   - 每个Bank有单独的端口，但仍需要知道如何选择正确的端口处理请求。
2. **共享端口（Shared Port）**
   - 共享一个端口，利用多路复用来处理多个请求。
   - 如果存储器访问延迟远小于请求延迟时，这种方法最有效。
   - 需要标记（tag）请求以明确响应来源。

### **如何设计大容量存储器？**

- 单一存储器容量有限，因此Bank化设计往往是不可避免的。
- 某些应用对容量需求很高，但却有**过剩的带宽**，Bank化可以充分利用这些资源。

## 优化存储器带宽需求

### **平滑存储器带宽需求**

**问题**: 存储器的**峰值带宽需求**通常决定了其成本（超出容量的部分）。

- 许多应用程序的存储带宽使用具有**突发性**（Bursty），短时高需求，而平均带宽使用较低。
- 理想情况下，应只需支付满足**平均带宽需求**的成本，而非峰值。

**解决方案**: **平滑带宽需求**

- 减少突发性，保持应用程序连续通信。
- 常见方法：**流水线化（Pipelining）** 和 **双缓冲（Double Buffering）**。

**示例**:

- 图示中蓝色的突发流量通过优化变为绿色的平滑流量，降低峰值到平均水平，从而更高效利用资源。

### **架构干预：重叠通信与计算**

**问题**:

- 当存储器进行读/写操作时，计算单元处于空闲状态，导致性能浪费。

**解决方案**:

- 重叠存储器访问（通信）和计算
  - 是**流水线化**的一种实现。
  - 需要增加**并行性**，以便在当前数据计算的同时向存储器发送更多请求。

**效果对比**:

- **无重叠**: 通信和计算依次进行，计算单元在通信时空闲。
- **重叠**: 通信和计算同时进行，显著提高了系统资源的利用率。

### **架构干预：双缓冲技术（Double Buffering）**

**问题**:

- 想要实现通信与计算的重叠，但现有存储器的端口或带宽不足。

**解决方案**:

- 双缓冲

  : 使用两个存储器（缓冲区）。

  - 一个存储器为计算单元提供数据（计算）。
  - 另一个存储器用于与外部通信（通信）。
  - 任务完成后，两者角色互换，循环使用。

**过程**:

1. 阶段 1

   :

   - **计算**从**存储器 1**获取数据。
   - **通信**操作将数据写入或从**存储器 2**读取。

2. 阶段 2

   :

   - **计算**和**通信**的角色对调，继续下一轮工作。

**优点**:

- 减少了存储器访问和计算之间的冲突，实现高效资源利用。

## 实践中的存储器实例化

### **离片存储器（Off-chip Memories）**

- 通常会精心选择和规划接口。

### **片上存储器（On-chip Memories）**

- ASIC

  中通常使用寄存器或SRAM：

  - 通过晶圆厂提供的SRAM阵列，或通过**存储器编译器**生成。
  - 根据需要调整存储器的大小和架构，以优化性能。

- FPGA

  中通常使用寄存器、LUT RAM、BRAM、URAM：

  - 工具会通过 Verilog 分析存储需求，并推断出所需的存储器。
  - 有时需要通过手动调整或提示工具来生成理想的存储结构。

### **Chisel 的存储器描述**

- Chisel 提供了一种对存储器行为的描述，但不直接涉及技术细节：
  - 对于**寄存器**和 FPGA 的 BRAM/URAM 足够。
  - 对于**SRAM**，通常需要使用黑盒（blackbox）包装厂商提供的接口。
  - Chisel 可以灵活地指定存储器的读写端口。

## 总结 - 物理设计入门 + 存储器优化

### **在设计硬件或优化前的思考**

1. 明确为什么需要构建硬件，而不是用 CPU 编程：
   - 量化 PPA（功耗、性能、面积），与目标需求比较。
2. 尽早闭环：
   - 结合设计与后端工具的反馈发现问题，减少反复优化的次数。
3. 使用 **Little's Law** 理解延迟、吞吐量和并行性之间的关系。

### **存储器优化的重要性**

- 存储器优化（离片或片上）应优先完成：
  - 对成本影响较大。
  - 改变存储器类型或结构需要较大的变动，且晚期更改代价高昂。

### **优化策略**

- **Bank化（Banking）**: 增加并行性，平衡带宽需求。
- **流量整形（Traffic Shaping）**: 平滑带宽需求。
- **通信与计算重叠（Comm. + Comp. Overlap）**: 提高资源利用率。
- **双缓冲（Double Buffering）**: 实现高效计算与通信互补。
