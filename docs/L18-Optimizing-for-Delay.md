## 优化延迟 (Optimizing for Delay)

### 今日计划

- 逻辑延迟的来源
- 减少延迟的技术

### 在笔记本中加载 Chisel 库

```scala
interp.load.module(os.Path(s"${System.getProperty("user.dir")}/../resource/chisel_deps.sc"))

import chisel3._
import chisel3.util._
import chiseltest._
import chiseltest.RawTester.test
```

### 延迟的来源

1. **门延迟 (Gate Delay)**
   - 表示门电路完成计算所需的时间。
   - **更复杂的逻辑门**或更多的输入（**fan-in**）会增加门延迟。
2. **线延迟 (Wire Delay)**
   - 表示信号在逻辑门之间传输所需的时间。
   - **fan-out**（从一个输出广播到多个输入）会加重线延迟。
   - 在线路更长的**FPGA**中，线延迟通常更明显。

图示：

- **蓝色**：门延迟
- **橙色**：线延迟
- **绿色**：fan-out（从一个输出分散到多个输入）

### 延迟单位

1. **常见时间单位**
   - 纳秒 (ns)：10⁻⁹ 秒
   - 皮秒 (ps)：10⁻¹² 秒
2. **Fanout of 4 (FO4)**
   - FO4 是一种与技术无关的延迟单位，略微对工艺技术或工作电压不敏感。
   - 示例：英特尔 Pentium 4 处理器 (3.4 GHz) 的 FO4 约为 16.3，换算为 18ps。

图示：FO4 表示一个逻辑门的输出驱动 4 个逻辑门输入时的延迟。

### 临界路径 (Critical Path)

1. **定义**
   - 临界路径是设计中延迟最长的路径（在最坏情况下）。
   - 时钟周期必须长于临界路径的延迟。
2. **特点**
   - 设计中比临界路径“更短”的路径不会影响时钟频率。
3. **减少临界路径延迟的益处**
   - 可以**提高时钟频率**，从而提升性能。
   - 可以**降低供电电压**，从而降低功耗。

图示：

- 蓝色路径是电路中的临界路径，它决定了设计的最大运行频率。

## 静态时序分析 (Static Timing Analysis, STA)

### 什么是静态时序分析？

静态时序分析是一种**分析设计并确定其时序行为**的过程。它的主要目标是评估设计中逻辑门和连线的时序表现，通常会关注最坏情况下的性能。

1. **核心目标：**
   - 评估逻辑门 (Gate) 和连线 (Wire) 的时延性能。
   - 找出设计中最坏情况下的时延路径，从而确定时钟周期。
2. **分析范围：**
   - STA 可以在合成阶段（仅考虑门延迟）之后进行，也可以在布线完成后进行（包括线延迟）。
3. **分析过程：**
   - STA 不会运行实际信号，而是基于**模型**和**公式**计算设计的延迟性能。
   - 每个门和连线的延迟被建模并累积，形成输入时间 (input arrival time) 和输出时间 (output time)。
4. **图解示例：**
   - 图中展示了逻辑门的延迟计算过程，每个门和连线都有具体的延迟值。
   - **绿色数字**：门的延迟时间。
   - **蓝色数字**：输入到达时间。
   - **橙色数字**：输出时间，基于输入时间加上门延迟计算得出。

## 修复临界路径 (Fixing Critical Paths)

尽管设计中大多数路径都很“短”（延迟较小），但时钟周期却是由**临界路径**决定的。

1. **为何优化临界路径？**
   - 减少临界路径延迟可以**缩短时钟周期**，从而提高吞吐量（假设没有数据冒险或气泡）。
2. **优化过程：**
   - 优化设计中延迟最长的路径（临界路径），通过减少其延迟来提高性能。
   - 一旦最长路径被优化，继续优化下一个最长路径，重复此过程，直到达到目标时钟周期。
   - 通常，工具可以完成一部分优化，但较大的改动需要**设计人员的干预**。
3. **挑战：**
   - 优化临界路径是一个非常耗时的过程，因为需要**逐步识别并优化多条路径**。
   - 而且某些路径的优化可能会对其他路径产生影响，因此需要不断迭代和验证。
4. **优化前后对比图：**
   - **优化前**：设计中许多路径的延迟分布超过目标时钟周期。
   - **优化后**：通过优化，绝大部分路径的延迟被压缩到目标周期以下。

## 谁来修复延迟问题？ (Who Fixes Delay?)

延迟优化的责任可以分为**工具的职责**和**设计师的职责**。这两者需要相互配合，避免冗余工作。

### 工具的职责

1. **优化逻辑设计**：
   - 基于几十年的研究，工具可以有效地优化逻辑设计，减少逻辑门数量，从而降低延迟。
   - 工具还可以通过**重组逻辑结构**来优化延迟。
2. **使用更快的组件**：
   - 工具能够选择性能更高的组件，但这通常需要以增加面积或功耗为代价。
3. **无语义变化的优化**：
   - 工具的优势在于优化设计时不会改变其语义（功能逻辑保持不变）。

### 设计师的职责

1. **改变设计语义**：
   - 工具无法修改设计语义，因此需要设计师从更高层次考虑架构改动以实现更高效的逻辑。
2. **考虑架构改动**：
   - 如果工具优化的潜力已达上限，设计师可能需要重新考虑整体架构设计。
3. **为工具优化创造条件**：
   - 设计师需要在设计中引入更多灵活性和优化空间，使工具能够更好地发挥其能力。

### 总结

- **工具和设计师是互补的**：工具擅长精细优化，而设计师则能从宏观视角对架构进行重大调整。
- 延迟优化通常是一个**迭代的过程**，需要工具和设计师的多轮配合才能完成。

## 流水线设计（Pipelining）

### 流水线的概念

流水线是一种通过在**长的组合路径中插入寄存器**来打破路径的方法。虽然数据仍然会沿着长路径传输，但这些数据将在**多个时钟周期**内完成传输。
 这种方法引入了**并行性**，因为多个数据元素可以同时在不同的阶段中传输。

1. **流水线的好处：**
   - **缩短临界路径**：通过将长的组合路径分割成更短的路径，降低了延迟。
   - **提高吞吐量**：多个数据片段可以同时处理，从而提升系统的总吞吐量。
2. **寄存器的位置：**
   - 寄存器的位置需要**平衡延迟**，避免一个阶段的路径过长。
   - 某些情况下，插入寄存器的位置可能非常明确，但在某些设计中，这可能需要仔细调整。
3. **手动调整的复杂性：**
   - 手动在设计中插入寄存器可能会很复杂，尤其是在需要多次迭代或不断调整的场景中。
   - 需要注意的是，在寄存器之间逻辑的前后移动可能耗费大量时间和精力。

#### 图示分析

- **原始设计**：具有一个长的组合路径，临界路径较长，限制了时钟频率。
- **流水线设计**：通过插入寄存器将长路径分割成多个更短的组合路径，缩短了临界路径，提高了性能。

## 重定时设计（Retiming）

### 重定时的概念

重定时是一种**自动化的寄存器调整方法**，工具会移动寄存器以平衡路径长度，从而优化时序。

1. **自动化优化：**
   - 工具可以分析路径并自动调整寄存器的位置，以实现更短的组合逻辑路径。
   - 工具的能力因其复杂性和灵活性而异，例如某些工具可能仅支持向前或向后移动寄存器。
2. **限制：**
   - 并非所有寄存器都能移动，例如当存在反馈回路时，重定时可能受到限制。
3. **验证复杂性：**
   - 虽然重定时在理论上能够优化时序，但可能会使设计的验证变得更加复杂。

#### 图示分析

- **原始设计**：具有一个长的组合路径，寄存器分布不均匀。
- **重定时设计**：通过移动寄存器，将长路径分割成多个更短的路径，实现更好的性能。

## 在 Chisel 中实现重定时的编码

### 如何使用 Chisel 实现流水线和重定时？

1. **参数化深度：**
   - 在 Chisel 中，可以通过参数化深度的方式为组件添加流水线功能。
2. **工具自动完成重定时：**
   - 通过使用工具，让其根据设计的需要调整寄存器位置，以优化路径分布。
3. **使用 Pipe 对象：**
   - Chisel 提供了 `Pipe` 对象，用于创建一系列寄存器（即移位寄存器）。
   - 通过 `Pipe`，可以轻松地在组合逻辑块末尾添加寄存器，也可以让工具根据需要移动寄存器。

#### 示例代码

```scala
class PipelineModule(pipelineDepth: Int) extends Module {
  val io = IO ...
  // 组合逻辑产生结果 result
  io.out := Pipe(result, pipelineDepth)
}
```

- 示例中的 `Pipe` 将在组合逻辑块末尾插入额外的寄存器。
- 工具可能会根据需要将寄存器移动到逻辑块的前端。

## 减少结构深度（Reduce Depth of Structures）

### 为何要减少逻辑深度？

逻辑优化工具可以解决许多非必要的低效问题，但有时仍需要**设计者的干预**。

1. **工具的局限性：**
   - 工具被限制于保持可观测行为不变，因此它们无法进行涉及设计语义的重大更改。
   - 某些极端的设计角落案例可能会导致工具无法优化。
2. **设计者的介入：**
   - 如果逻辑深度随着设计规模线性增长，设计者需要手动调整，如使用流水线或构造树状结构。
   - 尽管设计是线性的，但它可能不是临界路径，优化前需要确认。
3. **注意逻辑深度的增长：**
   - **流水线设计**：引入更多寄存器以减少单个阶段的逻辑深度。
   - **树状结构**：通过层次化设计降低延迟，虽然可能以面积为代价。

### 优化建议

- **确认临界路径**：优化前确保问题路径是临界路径。
- **小心过度优化**：有时工具已经很好地优化了路径，不需要额外调整。

### 总结

- **流水线**：通过插入寄存器将长路径分割成更短的路径，从而提高性能。
- **重定时**：自动化调整寄存器的位置以优化路径分布，减少延迟。
- **减少结构深度**：需要设计者手动干预，通过流水线或树状结构解决线性增长的深度问题。
- 在设计和优化过程中，设计者与工具需要相辅相成，以实现最佳的性能和效率。

## 示例：深度优化（以归约操作为例）

深度优化在硬件设计中非常重要，尤其是当需要处理大量输入数据时。如果逻辑深度过长，会导致较高的延迟并限制系统时钟频率。在本例中，通过对归约操作（Reduction）的深度进行优化，展示如何有效地减少逻辑延迟。

### **线性归约 vs 树状归约**

#### **线性归约 (Linear Reduction)**

- 每次操作只处理两个输入，依次逐步归约。
- 总的操作深度为 **n-1**，其中 n 是输入的数量。
- **问题**：当 n 较大时，深度过长，延迟较高。

#### **树状归约 (Tree Reduction)**

- 使用二叉树结构，将输入递归分成更小的子集，同时并行处理多个操作。

- 总的操作深度为 **log(n)**，其中 n 是输入的数量。

- 优点：

  - 通过并行化显著降低深度。
  - 非常适合硬件设计中大规模并行计算的场景。

**图示对比**：

- **线性归约**的延迟随输入大小线性增加。
- **树状归约**通过并行处理，将延迟限制在对数级别（log(n)）。

### **代码实现：PopCount 示例**

#### **线性归约的实现**

```scala
def linearPopCount(l: Seq[Bool]): UInt = {
  if (l.isEmpty) 0.U
  else l.head +& linearPopCount(l.tail)
}
```

- 解释：

  - 输入是一个布尔值序列 `l`。
  - 使用递归的方式，逐个累加布尔值。
  - 如果序列为空，返回 0。
  - 此方法的深度为 n-1（线性深度）。

#### **树状归约的实现**

```scala
def treePopCount(l: Seq[Bool]): UInt = l.size match {
  case 0 => 0.U
  case 1 => l.head
  case n => treePopCount(l take n/2) +& treePopCount(l drop n/2)
}
```

- 解释：

  - 输入同样是布尔值序列 `l`。
  - 通过递归将序列分成两部分，分别计算其布尔值的累加和。
  - 两部分的结果再归约为最终结果。
  - 此方法的深度为 log(n)（对数深度）。

### **模块化实现 PopCount**

下面是将上述逻辑封装到一个 Chisel 模块中的实现：

```scala
class CountOnes(n: Int) extends Module { // PopCount 模块
  val io = IO(new Bundle {
    val in = Input(Vec(n, Bool())) // 输入为布尔值向量
    val out = Output(UInt())      // 输出为累加值
  })
  
  require(n > 0) // 确保输入大小大于 0
  
  io.out := linearPopCount(io.in)    // 使用线性归约
  io.out := treePopCount(io.in)      // 使用树状归约
  io.out := PopCount(io.in)          // 使用 Chisel 自带的优化工具
}
```

- 输入输出：

  - `in` 是一个布尔值向量，表示需要进行归约操作的数据。
  - `out` 是归约操作的输出，为布尔值向量中为 `true` 的数量。

- 实现：

  - `linearPopCount` 实现线性归约。
  - `treePopCount` 实现树状归约。
  - 使用 `chisel3.util.PopCount` 是 Chisel 内置的优化实现，建议优先使用。

### **生成 Verilog**

通过以下命令生成该模块的 Verilog 文件：

```scala
printVerilog(new CountOnes(4))
```

生成的 Verilog 文件将对应 `CountOnes` 模块的硬件描述。

### **总结**

- **线性归约**虽然简单易懂，但在输入数量较多时，延迟可能过高，限制性能。
- **树状归约**通过并行化显著降低了逻辑深度，适合硬件设计中性能敏感的场景。
- **Chisel 内置工具**（如 `PopCount`）通常已经实现了最佳的性能和资源折中，建议优先使用。
- 使用树状结构优化逻辑深度是减少延迟、提升系统时钟频率的常用策略。
